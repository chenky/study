# python中的数据结构有不可变：数字类型，字符串类型，元组类型，可变：列表，集合，字典

# 字典通常也被称为映射、散列表、查找表或关联数组。字典能够高效查找、插入和删除任何与给定键关联的对象。

# Python字典基于经过充分测试和精心调整过的散列表实现，提供了符合期望的性能特征。一般情况下，用于查找、插入、更新和删除操作的时间复杂度都为O(1)。

# from types import MappingProxyType
# writable = {'one':1,'two':2}
# read_only = MappingProxyType(writable)
# print(read_only['one'])
# print(read_only['two'])
'''
字典是Python中的核心数据结构。
大部分情况下，内置的dict类型就足够了。
Python标准库提供了用于满足特殊需求的实现，比如只读字典或有序字典。
'''

# 数组将信息存储在依次连接的内存块中，所以它是连续的数据结构（与链式列表等链式数据结构不同）
# 在性能方面，根据元素的索引能快速查找数组中对应的元素。合理的数组实现能够确保索引访问的耗时为常量时间O(1)。

# arr=1,2,3
# arr[1]=5
# print(arr+(4,))
# 元组可以持有任意类型的数据：
#（添加元素会创建新元组）

'''
Python的array模块占用的空间较少，用于存储C语言风格的基本数据类型（如字节、32位整数，以及浮点数等）。
使用array.array类创建的数组是可变的，行为与列表类似。但有一个重要的区别：这种数组是单一数据类型的“类型数组”。
'''

# arr = 'abcd'
# arr[1]='f'


# bytes对象是单字节的不可变序列，单字节为0～255（含）范围内的整数。15从概念上讲，bytes与str对象类似，可认为是不可变的字节数组。

# bytearray类型是可变整数序列16，包含的整数范围在0～255（含）。bytearray与bytes对象关系密切，
# 主要区别在于bytearray可以自由修改，如覆盖、删除现有元素和添加新元素，此时bytearray对象将相应地增长和缩小。

'''
如果需要存储任意对象，且其中可能含有混合数据类型，那么可以选择使用列表或元组，前者可变后者不可变。
如果存储数值（整数或浮点数）数据并要求排列紧密且注重性能，那么先尝试array.array，看能否满足要求。另外可尝试准库之外的软件包，如NumPy或Pandas。
如果有需要用Unicode字符表示的文本数据，那么可以使用Python内置的str。如果需要用到“可变字符串”，则请使用字符列表。
如果想存储一个连续的字节块，不可变的请使用bytes，可变的请使用bytearray。
总之，在大多数情况下首先应尝试列表。如果在性能或存储空间上有问题，再选择其他专门的数据类型。一般像列表这样通用的数组型数据结构已经能同时兼顾开发速度和编程便利性的要求了。
强烈建议在初期使用通用数据格式，不要试图在一开始就榨干所有性能。
'''

# Python元组是简单的数据结构，用于对任意对象进行分组。19元组是不可变的，创建后无法修改。
# 在性能方面，元组占用的内存略少于CPython中的列表20，构建速度也更快。

'''
那么在Python中应该使用哪种类型的数据对象呢？从上面可以看到，Python中有许多不同的方法实现记录或数据对象，使用哪种方式通常取决于具体的情况。
如果只有两三个字段，字段顺序易于记忆或无须使用字段名称，则使用简单元组对象。例如三维空间中的(x, y, z)点。
如果需要实现含有不可变字段的数据对象，则使用collections.namedtuple或typing.NamedTuple这样的简单元组。
如果想锁定字段名称来避免输入错误，同样建议使用collections.namedtuple和typing.NamedTuple。
如果希望保持简单，建议使用简单的字典对象，其语法方便，和JSON也类似。
如果需要对数据结构完全掌控，可以用@property加上设置方法和获取方法来编写自定义的类。
如果需要向对象添加行为（方法），则应该从头开始编写自定义类，或者通过扩展collections.namedtuple或typing.NamedTuple来编写自定义类。
如果想严格打包数据以将其序列化到磁盘上或通过网络发送，建议使用struct.Struct。
一般情况下，如果想在Python中实现一个普通的记录、结构体或数据对象，我的建议是在{\rm Python}~2.x中使用collections.namedtuple，在Python 3中使用其姊妹typing.NamedTuple。
'''

'''
集合是Python及其标准库中含有的另一种有用且常用的数据结构。
查找可变集合时可使用内置的set类型。
frozenset对象可散列且可用作字典和集合的键。
collections.Counter实现了多重集合或“背包”类型的数据。
'''

# arr=[]
# arr.append("a")
# arr.append("b")
# arr.append('c')

# arr.pop()
# arr.pop()

# deque类实现了一个双端队列，支持在O(1)时间（非均摊）从两端添加和移除元素。因为双端队列支持从两端添加和删除元素，所以既可以作为队列也可以作为栈
# Python的deque对象以双向链表实现，这为插入和删除元素提供了出色且一致的性能，但是随机访问位于栈中间元素的性能很差，耗时为O(n)。

'''
列表底层是动态数组，因此适用于快速随机访问，但在添加或删除元素时偶尔需要调整大小。列表会预先分配一些备用存储空间，
因此不是每个入栈或出栈操作都需要调整大小，这些操作的均摊时间复杂度为O(1)。但需要小心，只能用append()和pop()从“右侧”插入和删除元素，否则性能会下降为O(n)。
collections.deque底层是双向链表，为从两端的添加和删除操作进行了优化，为这些操作提供了一致的O(1)性能。collections.deque不仅性能稳定，
而且便于使用，不必担心在“错误的一端”添加或删除项。
'''

'''
Python核心语言及其标准库中含有几种队列实现。
列表对象可以用作队列，但由于性能较差，通常不建议这么做。
如果不需要支持并行处理，那么collections.deque是Python中实现FIFO队列数据结构的最佳选择。collections.deque是非常优秀的队列实现，具备期望的性能特征，并且可以用作栈（LIFO队列）
'''

'''
Python提供了几种优先队列实现可以使用。
queue.PriorityQueue是其中的首选，具有良好的面向对象的接口，从名称就能明白其用途。
如果想避免queue.PriorityQueue的锁开销，那么建议直接使用heapq模块。
'''
